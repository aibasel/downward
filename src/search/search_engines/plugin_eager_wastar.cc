#include "eager_search.h"
#include "search_common.h"

#include "../option_parser.h"
#include "../plugin.h"

using namespace std;

namespace plugin_eager_wastar {
static shared_ptr<SearchEngine> _parse(OptionParser &parser) {
    parser.document_synopsis(
	"(Weighted) A* search (eager)",
	"");
    parser.document_note(
        "Open lists",
        "In the general case, it uses an alternation open list "
        "with one queue for each evaluator h that ranks the nodes "
        "by g + w * h. If preferred operator evaluators are used, "
        "it adds for each of the evaluators another such queue that "
        "only inserts nodes that are generated by preferred operators. "
        "In the special case with only one evaluator and no preferred "
        "operator evaluators, it uses a single queue that "
        "is ranked by g + w * h. ");
    parser.document_note(
        "Equivalent statements using general lazy search",
        "\n```\n--evaluator h1=eval1\n"
        "--search eager_wastar([eval1], w=2)\n"
        "is equivalent to\n"
        "```\n--search eager(single(sum([g(), weight(eval1, 2)])), reopen_closed=true)\n```\n"
        "------------------------------------------------------------\n"
        "Important: The Weighted A* search uses an alternation open list"
	"while A* search uses a tie-breaking open list. Consequently,"
        "\n```\n--evaluator h1=eval1\n"
        "--search eager_wastar([eval1], w=1)\n"
        "is NOT equivalent to\n"
        "```\n--search astar(eval1)\n```\n",
        true);

    parser.add_list_option<shared_ptr<Evaluator>>(
        "evals",
        "evaluators");
    parser.add_list_option<shared_ptr<Evaluator>>(
        "preferred",
        "use preferred operators of these evaluators",
	"[]");
    parser.add_option<bool>(
        "reopen_closed",
        "reopen closed nodes",
	"true");
    parser.add_option<int>(
        "boost",
        "boost value for preferred operator open lists",
	"0");
    parser.add_option<int>(
        "w",
        "evaluator weight",
	"1");

    SearchEngine::add_pruning_option(parser);
    SearchEngine::add_options_to_parser(parser);
    Options opts = parser.parse();

    if (parser.dry_run()) {
	return nullptr;
    }
    else {
        opts.set("open", search_common::create_wastar_open_list_factory(opts));
        return make_shared<eager_search::EagerSearch>(opts);
    }

}

static Plugin<SearchEngine> _plugin("eager_wastar", _parse);
}
