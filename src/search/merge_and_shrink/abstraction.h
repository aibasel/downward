#ifndef MERGE_AND_SHRINK_ABSTRACTION_H
#define MERGE_AND_SHRINK_ABSTRACTION_H

#include "equivalence_relation.h"
#include "shrink_strategy.h"

#include "../operator_cost.h"

#include <ext/slist>
#include <vector>

class Label;
class Labels;
class State;

struct AbstractTransition {
    AbstractStateRef src;
    AbstractStateRef target;

    AbstractTransition(AbstractStateRef src_, AbstractStateRef target_)
        : src(src_), target(target_) {
    }

    bool operator==(const AbstractTransition &other) const {
        return src == other.src && target == other.target;
    }

    bool operator!=(const AbstractTransition &other) const {
        return !(*this == other);
    }

    bool operator<(const AbstractTransition &other) const {
        return src < other.src || (src == other.src && target < other.target);
    }
};

class Abstraction {
    friend class AtomicAbstraction;
    friend class CompositeAbstraction;

    friend class ShrinkStrategy; // for apply() -- TODO: refactor!

    static const int PRUNED_STATE = -1;
    static const int DISTANCE_UNKNOWN = -2;

    const bool is_unit_cost;
    // There should only be one instance of Labels at runtime. It is created
    // and managed by MergeAndShrinkHeuristic. All abstraction instances have
    // a copy of the object required for label reduction and normalization.
    Labels *labels;
    // The set of relevant labels will *never* be updated after label reduction
    // and is thus *out dated* as soon as new labels have been generated by
    // label reduction. The only use of relevant labels is for approximative
    // label reduction.
    // TODO: can we get rid of this and have a method is_label_relevant(label)
    // that checks if transitions_by_label has an entry for label instead?
    std::vector<const Label *> relevant_labels;
    int num_states;
    std::vector<std::vector<AbstractTransition> > transitions_by_label;
    // The number of labels that this abstraction is "aware of", i.e. that have
    // been incorporated into transitions_by_label. Whenever new labels are
    // generated through label reduction, we do *not* update all abstractions
    // immediately.
    int num_labels;

    std::vector<int> init_distances;
    std::vector<int> goal_distances;
    std::vector<bool> goal_states;
    AbstractStateRef init_state;

    int max_f;
    int max_g;
    int max_h;

    bool normalized;

    mutable int peak_memory;

    void clear_distances();
    void compute_init_distances_unit_cost();
    void compute_goal_distances_unit_cost();
    void compute_init_distances_general_cost();
    void compute_goal_distances_general_cost();

    void apply_abstraction(std::vector<__gnu_cxx::slist<AbstractStateRef> > &collapsed_groups);

    int total_transitions() const;
    int unique_unlabeled_transitions() const;
protected:
    std::vector<int> varset;

    virtual AbstractStateRef get_abstract_state(const State &state) const = 0;
    virtual void apply_abstraction_to_lookup_table(const std::vector<
                                                       AbstractStateRef> &abstraction_mapping) = 0;
    virtual int memory_estimate() const;
public:
    Abstraction(bool is_unit_cost, Labels *labels);
    virtual ~Abstraction();

    // Two methods to identify the abstraction in output.
    // tag is a convience method that upper-cases the first letter of
    // description and appends ": ";
    virtual std::string description() const = 0;
    std::string tag() const;

    static void build_atomic_abstractions(bool is_unit_cost,
        std::vector<Abstraction *> &result, Labels *labels);
    bool is_solvable() const;

    int get_cost(const State &state) const;
    int size() const;
    void statistics(bool include_expensive_statistics) const;

    int get_peak_memory_estimate() const;
    // NOTE: This will only return something useful if the memory estimates
    //       have been computed along the way by calls to statistics().
    // TODO: Find a better way of doing this that doesn't require
    //       a mutable attribute?

    bool is_in_varset(int var) const;

    void compute_distances();
    bool is_normalized() const;
    void normalize();
    EquivalenceRelation compute_local_equivalence_relation(/*std::vector<std::pair<int, int> > &labeled_label_nos*/) const;
    EquivalenceRelation compute_local_equivalence_relation2(/*std::vector<std::pair<int, int> > &labeled_label_nos*/) const;
    void release_memory();

    // For debugging purposes. sorted_unique() is currently to determine whether
    // an abstraction is normalized or not after construction (composite abstraction)
    // and shrinking (apply_abstraction)
    bool sorted_unique() const;
    void dump() const;

    // The following methods exist for the benefit of shrink strategies.
    int get_max_f() const;
    int get_max_g() const;
    int get_max_h() const;

    bool is_goal_state(int state) const {
        return goal_states[state];
    }

    int get_init_distance(int state) const {
        return init_distances[state];
    }

    int get_goal_distance(int state) const {
        return goal_distances[state];
    }

    // This method should be private but is public for shrink_bisimulation
    int get_label_cost_by_index(int label_no) const;
    // The following methods are shrink_bisimulation-exclusive
    int get_num_labels() const;
    const std::vector<AbstractTransition> &get_transitions_for_label(int label_no) const;

    // The following two getters serve the m&s heuristic for label reduction
    const std::vector<const Label *> &get_relevant_labels() const {
        return relevant_labels;
    }
    const std::vector<int> &get_varset() const {
        return varset;
    }
};

class AtomicAbstraction : public Abstraction {
    int variable;
    std::vector<AbstractStateRef> lookup_table;
protected:
    virtual std::string description() const;
    virtual void apply_abstraction_to_lookup_table(const std::vector<
                                                       AbstractStateRef> &abstraction_mapping);
    virtual AbstractStateRef get_abstract_state(const State &state) const;
    virtual int memory_estimate() const;
public:
    AtomicAbstraction(bool is_unit_cost, Labels *labels, int variable);
    virtual ~AtomicAbstraction();
};

class CompositeAbstraction : public Abstraction {
    Abstraction *components[2];
    std::vector<std::vector<AbstractStateRef> > lookup_table;
protected:
    virtual std::string description() const;
    virtual void apply_abstraction_to_lookup_table(
        const std::vector<AbstractStateRef> &abstraction_mapping);
    virtual AbstractStateRef get_abstract_state(const State &state) const;
    virtual int memory_estimate() const;
public:
    CompositeAbstraction(bool is_unit_cost, Labels *labels,
        Abstraction *abs1, Abstraction *abs2);
    virtual ~CompositeAbstraction();
};

#endif
